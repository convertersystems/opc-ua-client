<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ output extension="generated.cs" #>
<# 
var filename = this.Host.ResolvePath(@"References\Types.xsd");
var ns = new CodeNamespace();
XmlReader reader = null;
try
{
	XmlSchema xsd;
	var schemas = new XmlSchemas();

	reader = XmlReader.Create(filename);
	xsd = XmlSchema.Read(reader, null);

	var schemaSet = new XmlSchemaSet();
	schemaSet.Add(xsd);
	schemaSet.Compile();

	foreach (XmlSchema schema in schemaSet.Schemas())
	{
		schemas.Add(schema);
	}

	var exporter = new XmlCodeExporter(ns);
	var importer = new XmlSchemaImporter(schemas, CodeGenerationOptions.None, new ImportContext(new CodeIdentifiers(), false));

	foreach (XmlSchemaElement element in xsd.Elements.Values)
	{
		var mapping = importer.ImportTypeMapping(element.QualifiedName);
		exporter.ExportTypeMapping(mapping);
	}
#>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Workstation.ServiceModel.Ua
{
	using System;
	using System.Xml.Linq;

<#	var enums = ns.Types.OfType<CodeTypeDeclaration>().Where(tt=>tt.IsEnum).ToList();
	foreach (var t in enums) { #>
	[DataTypeId(DataTypeIds.<#= t.Name #>)]
	public enum <#= t.Name #> {
<#		foreach (var f in t.Members.OfType<CodeMemberField>()) { #>
		<#= f.Name.Replace('_','=') #>,
<#		} #>
	}
<#	} #>

<#	var classes = ns.Types.OfType<CodeTypeDeclaration>().Where(tt=>tt.IsClass
		&& tt.Name != "DataValue" && tt.Name != "DiagnosticInfo" && tt.Name != "ExpandedNodeId"
		&& tt.Name != "ExtensionObject" && tt.Name != "Guid" && tt.Name != "LocalizedText"
		&& tt.Name != "NodeId" && tt.Name != "QualifiedName" && tt.Name != "StatusCode"
		&& tt.Name != "Variant" && tt.Name != "XElement" && !tt.Name.StartsWith("ListOf")).ToList();
	foreach (var c in classes) { 
		var props = c.Members.OfType<CodeMemberProperty>().Where(pp=>!pp.Name.EndsWith("Specified")).ToList(); #>
	[BinaryEncodingId(ObjectIds.<#= c.Name #>_Encoding_DefaultBinary)]
	[XmlEncodingId(ObjectIds.<#= c.Name #>_Encoding_DefaultXml)]
	[DataTypeId(DataTypeIds.<#= c.Name #>)]
	public class <#= c.Name #><#= RenderBaseTypes(c) #> {
<#		foreach (var p in props) { #>
		public <#= RenderType(p.Type) #> <#= p.Name #> { get; set; }
<#		} #>
<#		if (c.BaseTypes.Count == 0) { #>
        public virtual void Encode(IEncoder encoder) {
            encoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<#			foreach (var p in props) { #>
			encoder.Write<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>", <#= p.Name #>);
<#			} #>
            encoder.PopNamespace();
        }
        public virtual void Decode(IDecoder decoder) {
            decoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<#		foreach (var p in props) { #>
			<#= p.Name #> = decoder.Read<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>");
<#		} #>
            decoder.PopNamespace();
        }
<#		} else { #>
        public override void Encode(IEncoder encoder) {
			base.Encode(encoder);
            encoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<#			foreach (var p in props) { #>
			encoder.Write<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>", <#= p.Name #>);
<#			} #>
            encoder.PopNamespace();
        }
        public override void Decode(IDecoder decoder) {
			base.Decode(decoder);
            decoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<#			foreach (var p in props) { #>
			<#= p.Name #> = decoder.Read<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>");
<#			} #>
            decoder.PopNamespace();
        }
<#		} #>
	}
<#	} #>
}
<# 
}
finally
{
	if (reader != null)
		reader.Dispose();
}
#>
<#+
string RenderType(CodeTypeReference t) 
{
	var name = GetShortName(t.BaseType); 
	if (t.ArrayRank > 0)
	{
		if (t.ArrayElementType.ArrayRank > 0)
		{
			// for case of ByteStringArray to render as 'Byte[][]'
			return string.Format("{0}[][]", name);
		}
		return string.Format("{0}[]", name);
	}
	return name;
}

string RenderBaseTypes(CodeTypeDeclaration type) 
{
	var types = type.BaseTypes;
	var sb = new StringBuilder();
	var flag = false;
	foreach (var t in types.OfType<CodeTypeReference>())
	{
		sb.Append(!flag ? " : " : ", "); 
		sb.Append(GetShortName(t.BaseType));
		flag = true;
	}
	if (flag)
	{
		return sb.ToString();
	}
	var props = type.Members.OfType<CodeMemberProperty>().ToList(); 
	var isRequest = props.Any(pp=>pp.Name == "RequestHeader");
	if (isRequest)
	{
		return " : IServiceRequest";
	}
	var isResponse = props.Any(pp=>pp.Name == "ResponseHeader");
	if (isResponse)
	{
		return " : IServiceResponse";
	}
	return " : IEncodable";
}

string RenderMethodSuffix(CodeTypeReference type, List<CodeTypeDeclaration> knownEnums) 
{
	var name = GetShortName(type.BaseType); 
	switch (name)
	{
		case "Boolean":
			return type.ArrayRank == 0 ? "Boolean" : "BooleanArray";
		case "SByte":
			return type.ArrayRank == 0 ? "SByte" : "SByteArray";
		case "Byte":
			return type.ArrayRank == 0 ? "Byte" : (type.ArrayElementType.ArrayRank == 0 ? "ByteString" : "ByteStringArray");
		case "Int16":
			return type.ArrayRank == 0 ? "Int16" : "Int16Array";
		case "UInt16":
			return type.ArrayRank == 0 ? "UInt16" : "UInt16Array";
		case "Int32":
			return type.ArrayRank == 0 ? "Int32" : "Int32Array";
		case "UInt32":
			return type.ArrayRank == 0 ? "UInt32" : "UInt32Array";
		case "Int64":
			return type.ArrayRank == 0 ? "Int64" : "Int64Array";
		case "UInt64":
			return type.ArrayRank == 0 ? "UInt64" : "UInt64Array";
		case "Single":
			return type.ArrayRank == 0 ? "Float" : "FloatArray";
		case "Double":
			return type.ArrayRank == 0 ? "Double" : "DoubleArray";
		case "String":
			return type.ArrayRank == 0 ? "String" : "StringArray";
		case "DateTime":
			return type.ArrayRank == 0 ? "DateTime" : "DateTimeArray";
		case "Guid":
			return type.ArrayRank == 0 ? "Guid" : "GuidArray";
		case "XElement":
			return type.ArrayRank == 0 ? "XElement" : "XElementArray";
		case "NodeId":
			return type.ArrayRank == 0 ? "NodeId" : "NodeIdArray";
		case "ExpandedNodeId":
			return type.ArrayRank == 0 ? "ExpandedNodeId" : "ExpandedNodeIdArray";
		case "StatusCode":
			return type.ArrayRank == 0 ? "StatusCode" : "StatusCodeArray";
		case "QualifiedName":
			return type.ArrayRank == 0 ? "QualifiedName" : "QualifiedNameArray";
		case "LocalizedText":
			return type.ArrayRank == 0 ? "LocalizedText" : "LocalizedTextArray";
		case "ExtensionObject":
			return type.ArrayRank == 0 ? "ExtensionObject" : "ExtensionObjectArray";
		case "DataValue":
			return type.ArrayRank == 0 ? "DataValue" : "DataValueArray";
		case "Variant":
			return type.ArrayRank == 0 ? "Variant" : "VariantArray";
		case "DiagnosticInfo":
			return type.ArrayRank == 0 ? "DiagnosticInfo" : "DiagnosticInfoArray";
		// special cases to support encoding IEncodable as ExtensionObject
		case "UserIdentityToken":
			return type.ArrayRank == 0 ? "ExtensionObject<UserIdentityToken>" : "ExtensionObjectArray<UserIdentityToken>";
		case "NodeAttributes":
			return type.ArrayRank == 0 ? "ExtensionObject<NodeAttributes>" : "ExtensionObjectArray<NodeAttributes>";
		case "FilterOperand":
			return type.ArrayRank == 0 ? "ExtensionObject<FilterOperand>" : "ExtensionObjectArray<FilterOperand>";
		case "HistoryData":
			return type.ArrayRank == 0 ? "ExtensionObject<HistoryData>" : "ExtensionObjectArray<HistoryData>";
		case "HistoryReadDetails":
			return type.ArrayRank == 0 ? "ExtensionObject<HistoryReadDetails>" : "ExtensionObjectArray<HistoryReadDetails>";
		case "MonitoringFilter":
			return type.ArrayRank == 0 ? "ExtensionObject<MonitoringFilter>" : "ExtensionObjectArray<MonitoringFilter>";
		case "MonitoringFilterResult":
			return type.ArrayRank == 0 ? "ExtensionObject<MonitoringFilterResult>" : "ExtensionObjectArray<MonitoringFilterResult>";
		case "NotificationData":
			return type.ArrayRank == 0 ? "ExtensionObject<NotificationData>" : "ExtensionObjectArray<NotificationData>";

		default:
			if(knownEnums.Any(tt=>tt.Name == name))
			{
				return type.ArrayRank == 0 ? string.Format("Enumeration<{0}>", name) : string.Format("EnumerationArray<{0}>", name);
			}
			return type.ArrayRank == 0 ? string.Format("Encodable<{0}>", name) : string.Format("EncodableArray<{0}>", name);
	}
}

string GetShortName(string name)
{
	if (name == null) return null;
	return name.Substring(name.LastIndexOf('.') + 1);
} 

#>
